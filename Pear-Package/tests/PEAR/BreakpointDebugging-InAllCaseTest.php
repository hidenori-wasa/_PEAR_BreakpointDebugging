<?php

chdir(__DIR__ . '/../../');
require_once './BreakpointDebugging_Including.php';

use \BreakpointDebugging as B;
use \BreakpointDebugging_InAllCase as BA;
use \BreakpointDebugging_UnitTestOverridingBase as BU;

//B::isUnitTestExeMode('UNIT_TEST');
B::isUnitTestExeMode(true);

$testAutoload = 1;
if ($testAutoload === 1) { // The case which extends base class.
    class AutoloadTest extends \NativeClass
    {

    }

}
/**
 * Test class for BreakpointDebugging_InAllCase.
 * Generated by PHPUnit on 2012-09-30 at 16:24:30.
 */
class BreakpointDebugging_InAllCaseTest extends \BreakpointDebugging_UnitTestOverriding
{
    const TEST_CONST = 'The test constant.';

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    function test__initialize()
    {
        BA::initialize();
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    function testRefAndGetStatic()
    {
        $userName = &BA::refStatic('$_userName');
        $userName = 'hidenori';
        $this->assertTrue($userName === 'hidenori');
        $this->assertTrue(BA::getStatic('$_userName') === 'hidenori');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    function testSetAndGetXebugExists()
    {
        BA::setXebugExists(false);
        $this->assertTrue(BA::getXebugExists() === false);
        BA::setXebugExists(true);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testIniCheck()
    {
        ob_start();
        BA::iniCheck('safe_mode', '', 'Test message 1.');
        $this->assertTrue(ob_get_contents() === '');
        ob_clean();
        BA::iniCheck('safe_mode', 'On', 'Test message 2.');
        $this->assertTrue(ob_get_contents() !== '');
        ob_clean();
        BA::iniCheck('xdebug.remote_host', array ('Other1', 'Other2'), 'Test message 3.');
        $this->assertTrue(ob_get_contents() === '');
        ob_clean();
        BA::iniCheck('safe_mode', array ('', 'On'), 'Test message 4.');
        $this->assertTrue(ob_get_contents() !== '');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     *
     * @expectedException        \BreakpointDebugging_ErrorException
     * @expectedExceptionMessage CLASS=BreakpointDebugging_InAllCase FUNCTION=iniCheck ID=2
     */
    public function testIniCheck_B()
    {
        BA::iniCheck('safe_mode', array (123), 'Test message.');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testRegisterNotFixedLocation()
    {
        static $isRegister = false;

        BA::registerNotFixedLocation($isRegister);
        BA::registerNotFixedLocation($isRegister);
        $notFixedLocations = BA::getStatic('$_notFixedLocations');
        $notFixedLocation = $notFixedLocations[count($notFixedLocations) - 1];
        $this->assertTrue($notFixedLocation['function'] === 'testRegisterNotFixedLocation');
        $this->assertTrue($notFixedLocation['class'] === 'BreakpointDebugging_InAllCaseTest');
        $this->assertTrue(!array_key_exists('file', $notFixedLocation));
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testAddValuesToTrace()
    {
        $testString = 'The test character string.';
        $values = array ('TEST_CONST' => BreakpointDebugging_InAllCaseTest::TEST_CONST, '$testString' => $testString);
        BA::addValuesToTrace($values);
        $line = __LINE__ - 1;
        $valuesToTraces = BA::getStatic('$_valuesToTrace');
        $valuesToTrace = $valuesToTraces[__FILE__][$line];
        $this->assertTrue($valuesToTrace['function'] === 'testAddValuesToTrace');
        $this->assertTrue($valuesToTrace['class'] === 'BreakpointDebugging_InAllCaseTest');
        $this->assertTrue(!array_key_exists('file', $valuesToTrace));
        $this->assertTrue($valuesToTrace['values'] === $values);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testConvertMbString_A()
    {
        // SJIS
        BA::convertMbString("\x95\xB6\x8E\x9A ");
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testConvertMbString_B()
    {
        // UTF-8
        BA::convertMbString("\xE6\x96\x87\xE5\xAD\x97 ");
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     *
     * @expectedException        \BreakpointDebugging_ErrorException
     * @expectedExceptionMessage CLASS=BreakpointDebugging_InAllCase FUNCTION=convertMbString ID=3
     */
    public function testConvertMbString_C()
    {
        // SJIS + UTF-8
        BA::convertMbString("\x95\xB6\x8E\x9A \xE6\x96\x87\xE5\xAD\x97 ");
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testMkdir()
    {
        $testDirName = BA::getStatic('$_workDir') . '/TestMkDir';
        if (is_dir($testDirName)) {
            rmdir($testDirName);
        }
        BA::mkdir($testDirName, 0700);
        $this->assertTrue(is_dir($testDirName));
        if (BA::getStatic('$_os') === 'WIN') {
            return;
        }
        clearstatcache();
        $this->assertTrue(substr(sprintf('%o', fileperms($testDirName)), -4) === '0700');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testFopen()
    {
        $testFileName = BA::getStatic('$_workDir') . '/TestFopen.txt';
        if (is_file($testFileName)) {
            unlink($testFileName);
        }
        $pFile = BA::fopen($testFileName, 'w+b', 0700);
        fclose($pFile);
        $this->assertTrue(is_file($testFileName));
        if (BA::getStatic('$_os') === 'WIN') {
            return;
        }
        clearstatcache();
        $this->assertTrue(substr(sprintf('%o', fileperms($testFileName)), -4) === '0700');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testCompressThenDecompressIntArray()
    {
        $intArray = array ();
        for ($count = 0; $count <= 400; $count++) {
            $intArray[] = $count;
        }
        $pFile = fopen(BA::getStatic('$_workDir') . '/test.bin', 'w+b');
        fwrite($pFile, BA::compressIntArray($intArray));
        fwrite($pFile, BA::compressIntArray($intArray));
        fflush($pFile);
        rewind($pFile);
        while ($intResultArray = BA::decompressIntArray(fgets($pFile))) {
            $this->assertTrue($intArray === $intResultArray);
        }
        fclose($pFile);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testClearRecursiveArrayElement()
    {
        $testArray['element'] = 'String.';
        $testArray['recursive'] = &$testArray;
        $testArray['component']['recursive'] = &$testArray;
        $testArray['component']['element'] = 'String.';
        $testArray['component']['recursive2'] = &$testArray['component'];
        $testArray['component']['component']['recursive'] = &$testArray['component'];
        $testArray['component']['component']['GLOBALS'] = $GLOBALS;

        $expectedArray['element'] = 'String.';
        $expectedArray['recursive'] = B::RECURSIVE_ARRAY;
        $expectedArray['component']['recursive'] = B::RECURSIVE_ARRAY;
        $expectedArray['component']['element'] = 'String.';
        $expectedArray['component']['recursive2'] = B::RECURSIVE_ARRAY;
        $expectedArray['component']['component']['recursive'] = B::RECURSIVE_ARRAY;
        $expectedArray['component']['component']['GLOBALS'] = B::GLOBALS_USING;


        $resultArray = BA::clearRecursiveArrayElement($testArray);
        $this->assertTrue($expectedArray['element'] === $resultArray['element']
            && $expectedArray['recursive'] === $resultArray['recursive']
            && $expectedArray['component']['recursive'] === $resultArray['component']['recursive']
            && $expectedArray['component']['element'] === $resultArray['component']['element']
            && $expectedArray['component']['recursive2'] === $resultArray['component']['recursive2']
            && $expectedArray['component']['component']['recursive'] === $resultArray['component']['component']['recursive']
            && $expectedArray['component']['component']['GLOBALS'] === $resultArray['component']['component']['GLOBALS']
        );
        $this->assertTrue(is_array($GLOBALS));

        unset($expectedArray);
        $expectedArray['GLOBALS'] = B::GLOBALS_USING;

        $resultArray = BA::clearRecursiveArrayElement($GLOBALS);
        $this->assertTrue($expectedArray['GLOBALS'] === $resultArray['GLOBALS']);
        $this->assertTrue(is_array($GLOBALS));

        unset($testArray);
        $testArray = array ($GLOBALS);

        unset($expectedArray);
        $expectedArray[0]['GLOBALS'] = B::GLOBALS_USING;

        $resultArray = BA::clearRecursiveArrayElement($testArray);
        $this->assertTrue($expectedArray[0]['GLOBALS'] === $resultArray[0]['GLOBALS']);
        $this->assertTrue(is_array($GLOBALS));
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testAutoload()
    {
        global $testAutoload;

        if ($testAutoload === 2) { // In case of accessing to static member.
            ob_start();
            \NativeClass::publicStaticFunction();
        }

        if ($testAutoload === 3) { // In case of creating new instance.
            new \NativeClass();
        }
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testExceptionHandler()
    {
        $pPrevious = new \Exception('Previous exception.', E_USER_WARNING);
        $pException = new \Exception('Exception.', E_USER_WARNING, $pPrevious);
        BU::$exeMode |= B::IGNORING_BREAK_POINT;
        ob_start();
        BA::handleException($pException);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testErrorHandler()
    {
        BU::$exeMode |= B::IGNORING_BREAK_POINT;
        ob_start();
        BA::handleError(E_USER_WARNING, 'Error test.');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     *
     * @expectedException        \BreakpointDebugging_ErrorException
     * @expectedExceptionMessage CLASS=BreakpointDebugging_InAllCaseTest FUNCTION=testInternalException ID=1
     */
    public function testInternalException()
    {
        BU::$exeMode |= B::IGNORING_BREAK_POINT;
        BA::internalException('Tests "internalException()".', 1);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testShutdown()
    {
        // Emulates this page shutdown.
        BA::shutdown();
    }

    /**
     * @covers \BreakpointDebugging<extended>
     */
    public function testCheckUnitTestExeMode()
    {
//        B::setPropertyForTest('BreakpointDebugging_UnitTestCaller', '$unitTestDir', null);
//        BA::isUnitTestExeMode('DEBUG_UNIT_TEST');
//        BU::$exeMode = B::UNIT_TEST;
//        BA::isUnitTestExeMode('DEBUG_UNIT_TEST');
//        BU::$exeMode = B::RELEASE | B::UNIT_TEST;
//        BA::isUnitTestExeMode('RELEASE_UNIT_TEST');
//        BU::$exeMode = B::REMOTE | B::RELEASE | B::UNIT_TEST;
//        BA::isUnitTestExeMode('RELEASE_UNIT_TEST');

        BU::$exeMode = B::RELEASE;
        BA::isUnitTestExeMode();
//        BU::$exeMode = B::REMOTE | B::RELEASE;
//        BA::isUnitTestExeMode();
//        BU::$exeMode = B::RELEASE;
        //BA::isUnitTestExeMode('FALSE');
        BA::isUnitTestExeMode(false);
//        BU::$exeMode = B::REMOTE | B::RELEASE;
//        BA::isUnitTestExeMode('FALSE');
    }

    /**
     * @covers \BreakpointDebugging<extended>
     *
     * @expectedException        \BreakpointDebugging_ErrorException
     * @expectedExceptionMessage <pre>You must not set "$_BreakpointDebugging_EXE_MODE = BreakpointDebugging_setExecutionModeFlags('..._UNIT_TEST');"
     */
    public function testCheckUnitTestExeMode_A()
    {
        BU::$exeMode = B::RELEASE;
        //BA::isUnitTestExeMode('RELEASE_UNIT_TEST');
        BA::isUnitTestExeMode(true);
    }

//    /**
//     * @covers \BreakpointDebugging<extended>
//     *
//     * @expectedException        \BreakpointDebugging_ErrorException
//     * @expectedExceptionMessage <pre>You mistook "\BreakpointDebugging::isUnitTestExeMode('...');".</pre>
//     */
//    public function testCheckUnitTestExeMode_B()
//    {
//        BU::$exeMode = B::RELEASE;
//        BA::isUnitTestExeMode('DEBUG_UNIT_TEST');
//    }
//    /**
//     * @covers \BreakpointDebugging<extended>
//     *
//     * @expectedException        \BreakpointDebugging_ErrorException
//     * @expectedExceptionMessage <pre>You mistook "\BreakpointDebugging::isUnitTestExeMode('...');".</pre>
//     */
//    public function testCheckUnitTestExeMode_C()
//    {
//        BU::$exeMode = B::RELEASE;
//        BA::isUnitTestExeMode('Mistaken character string.');
//    }
}

?>

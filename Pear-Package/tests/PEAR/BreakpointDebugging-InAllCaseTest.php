<?php

chdir(__DIR__ . '/../../');
require_once './PEAR_Setting/BreakpointDebugging_MySetting.php';

use \BreakpointDebugging as B;

B::isUnitTestExeMode(true);

$testAutoload = 1;
if ($testAutoload === 1) { // The case which extends base class.
    class AutoloadTest extends \NativeClass
    {

    }

}
/**
 * Test class for BreakpointDebugging_InAllCase.
 * Generated by PHPUnit on 2012-09-30 at 16:24:30.
 */
class BreakpointDebugging_InAllCaseTest extends \BreakpointDebugging_UnitTestOverriding
{
    const TEST_CONST = 'The test constant.';

    private static $_exeMode;

    static function setUpBeforeClass()
    {
        self::$_exeMode = &B::refStatic('$exeMode');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    function test__construct()
    {
        new \BreakpointDebugging();
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    function testRefAndGetStatic()
    {
        $userName = &B::refStatic('$_userName');
        $userName = 'hidenori';
        $this->assertTrue($userName === 'hidenori');
        $this->assertTrue(B::getStatic('$_userName') === 'hidenori');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    function testSetAndGetXebugExists()
    {
        B::setXebugExists(false);
        $this->assertTrue(B::getXebugExists() === false);
        B::setXebugExists(true);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testIniCheck()
    {
        ob_start();
        B::iniCheck('safe_mode', '', 'Test message 1.');
        $this->assertTrue(ob_get_contents() === '');
        ob_clean();
        B::iniCheck('safe_mode', 'On', 'Test message 2.');
        $this->assertTrue(ob_get_contents() !== '');
        ob_clean();
        B::iniCheck('xdebug.remote_host', array ('Other1', 'Other2'), 'Test message 3.');
        $this->assertTrue(ob_get_contents() === '');
        ob_clean();
        B::iniCheck('safe_mode', array ('', 'On'), 'Test message 4.');
        $this->assertTrue(ob_get_clean() !== '');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     *
     * @expectedException        \BreakpointDebugging_ErrorException
     * @expectedExceptionMessage CLASS=BreakpointDebugging_InAllCase FUNCTION=iniCheck ID=2
     */
    public function testIniCheck_B()
    {
        B::iniCheck('safe_mode', array (123), 'Test message.');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testRegisterNotFixedLocation()
    {
        static $isRegister = false;

        B::registerNotFixedLocation($isRegister);
        B::registerNotFixedLocation($isRegister);
        $notFixedLocations = B::getStatic('$_notFixedLocations');
        $notFixedLocation = $notFixedLocations[count($notFixedLocations) - 1];
        $this->assertTrue($notFixedLocation['function'] === 'testRegisterNotFixedLocation');
        $this->assertTrue($notFixedLocation['class'] === 'BreakpointDebugging_InAllCaseTest');
        $this->assertTrue(!array_key_exists('file', $notFixedLocation));
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testAddValuesToTrace()
    {
        $testString = 'The test character string.';
        $values = array ('TEST_CONST' => BreakpointDebugging_InAllCaseTest::TEST_CONST, '$testString' => $testString);
        B::addValuesToTrace($values);
        $line = __LINE__ - 1;
        $valuesToTraces = B::getStatic('$_valuesToTrace');
        $valuesToTrace = $valuesToTraces[__FILE__][$line];
        $this->assertTrue($valuesToTrace['function'] === 'testAddValuesToTrace');
        $this->assertTrue($valuesToTrace['class'] === 'BreakpointDebugging_InAllCaseTest');
        $this->assertTrue(!array_key_exists('file', $valuesToTrace));
        $this->assertTrue($valuesToTrace['values'] === $values);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testConvertMbString_A()
    {
        // SJIS
        B::convertMbString("\x95\xB6\x8E\x9A ");
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testConvertMbString_B()
    {
        // UTF-8
        B::convertMbString("\xE6\x96\x87\xE5\xAD\x97 ");
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     *
     * @expectedException        \BreakpointDebugging_ErrorException
     * @expectedExceptionMessage CLASS=BreakpointDebugging_InAllCase FUNCTION=convertMbString ID=3
     */
    public function testConvertMbString_C()
    {
        // SJIS + UTF-8
        B::convertMbString("\x95\xB6\x8E\x9A \xE6\x96\x87\xE5\xAD\x97 ");
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testMkdir()
    {
        $testDirName = B::getStatic('$_workDir') . '/TestMkDir';
        if (is_dir($testDirName)) {
            rmdir($testDirName);
        }
        B::mkdir($testDirName, 0700);
        $this->assertTrue(is_dir($testDirName));
        if (B::getStatic('$_os') === 'WIN') {
            return;
        }
        clearstatcache();
        $this->assertTrue(substr(sprintf('%o', fileperms($testDirName)), -4) === '0700');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testFopen()
    {
        $testFileName = B::getStatic('$_workDir') . '/TestFopen.txt';
        if (is_file($testFileName)) {
            unlink($testFileName);
        }
        $pFile = B::fopen($testFileName, 'w+b', 0700);
        fclose($pFile);
        $this->assertTrue(is_file($testFileName));
        if (B::getStatic('$_os') === 'WIN') {
            return;
        }
        clearstatcache();
        $this->assertTrue(substr(sprintf('%o', fileperms($testFileName)), -4) === '0700');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testCompressThenDecompressIntArray()
    {
        $intArray = array ();
        for ($count = 0; $count <= 400; $count++) {
            $intArray[] = $count;
        }
        $pFile = fopen(B::getStatic('$_workDir') . '/test.bin', 'w+b');
        fwrite($pFile, B::compressIntArray($intArray));
        fwrite($pFile, B::compressIntArray($intArray));
        fflush($pFile);
        rewind($pFile);
        while ($intResultArray = B::decompressIntArray(fgets($pFile))) {
            $this->assertTrue($intArray === $intResultArray);
        }
        fclose($pFile);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testClearRecursiveArrayElement()
    {
        $testArray['element'] = 'String.';
        $testArray['recursive'] = &$testArray;
        $testArray['component']['recursive'] = &$testArray;
        $testArray['component']['element'] = 'String.';
        $testArray['component']['recursive2'] = &$testArray['component'];
        $testArray['component']['component']['recursive'] = &$testArray['component'];
        $testArray['component']['component']['GLOBALS'] = $GLOBALS;

        $expectedArray['element'] = 'String.';
        $expectedArray['recursive'] = B::RECURSIVE_ARRAY;
        $expectedArray['component']['recursive'] = B::RECURSIVE_ARRAY;
        $expectedArray['component']['element'] = 'String.';
        $expectedArray['component']['recursive2'] = B::RECURSIVE_ARRAY;
        $expectedArray['component']['component']['recursive'] = B::RECURSIVE_ARRAY;
        $expectedArray['component']['component']['GLOBALS'] = B::GLOBALS_USING;


        $resultArray = B::clearRecursiveArrayElement($testArray);
        $this->assertTrue($expectedArray['element'] === $resultArray['element']
            && $expectedArray['recursive'] === $resultArray['recursive']
            && $expectedArray['component']['recursive'] === $resultArray['component']['recursive']
            && $expectedArray['component']['element'] === $resultArray['component']['element']
            && $expectedArray['component']['recursive2'] === $resultArray['component']['recursive2']
            && $expectedArray['component']['component']['recursive'] === $resultArray['component']['component']['recursive']
            && $expectedArray['component']['component']['GLOBALS'] === $resultArray['component']['component']['GLOBALS']
        );
        $this->assertTrue(is_array($GLOBALS));

        unset($expectedArray);
        $expectedArray['GLOBALS'] = B::GLOBALS_USING;

        $resultArray = B::clearRecursiveArrayElement($GLOBALS);
        $this->assertTrue($expectedArray['GLOBALS'] === $resultArray['GLOBALS']);
        $this->assertTrue(is_array($GLOBALS));

        unset($testArray);
        $testArray = array ($GLOBALS);

        unset($expectedArray);
        $expectedArray[0]['GLOBALS'] = B::GLOBALS_USING;

        $resultArray = B::clearRecursiveArrayElement($testArray);
        $this->assertTrue($expectedArray[0]['GLOBALS'] === $resultArray[0]['GLOBALS']);
        $this->assertTrue(is_array($GLOBALS));
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testAutoload()
    {
        global $testAutoload;

        if ($testAutoload === 2) { // In case of accessing to static member.
            ob_start();
            \NativeClass::publicStaticFunction();
            ob_end_clean();
        }

        if ($testAutoload === 3) { // In case of creating new instance.
            new \NativeClass();
        }
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testExceptionHandler()
    {
        ob_start();
        $pPrevious = new \Exception('Previous exception.', E_USER_ERROR);
        $pException = new \Exception('Exception.', E_USER_ERROR, $pPrevious);
        self::$_exeMode |= B::IGNORING_BREAK_POINT;
        B::exceptionHandler($pException);
        self::$_exeMode &= ~B::IGNORING_BREAK_POINT;
        $this->assertTrue(ob_get_clean() !== '');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testErrorHandler()
    {
        ob_start();
        self::$_exeMode |= B::IGNORING_BREAK_POINT;
        B::errorHandler(E_USER_ERROR, 'Error test.');
        self::$_exeMode &= ~B::IGNORING_BREAK_POINT;
        $this->assertTrue(ob_get_clean() !== '');
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     *
     * @expectedException        \BreakpointDebugging_ErrorException
     * @expectedExceptionMessage CLASS=BreakpointDebugging_InAllCaseTest FUNCTION=testInternalException ID=1
     */
    public function testInternalException()
    {
        B::internalException('Tests "internalException()".', 1);
    }

    /**
     * @covers \BreakpointDebugging_InAllCase<extended>
     */
    public function testShutdown()
    {
        // Emulates this page shutdown.
        \BreakpointDebugging_InAllCase::shutdown();
    }

}

?>
